//  ******************************************************
// 
//     File generated by: neuroConstruct v1.7.1
// 
//  ******************************************************

{load_file("nrngui.hoc")}

//  Initialising stopwatch for timing setup

{startsw()}

print ""
print "*****************************************************"
print ""
print "    neuroConstruct generated NEURON simulation "
print "    for project: /home/padraig/nC_projects/Gaps/Gaps.ncx "
print ""
print "    Description: This is a simple project with a single cell placed randomly in a 3D rectangular box."
print "    "
print "    Go to tab Generate, press Generate Cell Positions and Connections, and then to visualise the results, go to tab Visualisation and press View, with Latest Generated Positions selected in the drop down box."
print "    "
print "    If NEURON or GENESIS are installed, the cell can be simulated via tab Export."
print ""
print "    Simulation Configuration: SimConfig: Default Simulation Configuration "
print "    This is the default configuration of the Cell Groups, stimulations, plots, etc for this project "
print " "
print  "*****************************************************"

strdef pwd
{system("pwd", pwd)}
print ""
print "Current working dir: ", pwd

objectvar allCells
{allCells = new List()}


//  A flag to signal simulation was generated by neuroConstruct 

{nC = 1}


//  Including neuroConstruct utilities file 

{load_file("nCtools.hoc")}

//  Including neuroConstruct cell check file 

{load_file("cellCheck.hoc")}

//  Getting hostname

objref strFuncs
{strFuncs = new StringFunctions()}
strdef host
{system("hostname", host)}
if (strFuncs.len(host)>0) {
    strFuncs.left(host, strFuncs.len(host)-1) 
} else {
    host = "????" 
}


//////////////////////////////////////////////////////////////////////
//   Initialising parallelization
//////////////////////////////////////////////////////////////////////

ncell = 2


//  Parallel NEURON setup

{load_file("netparmpi.hoc")}
objref pnm
{pnm = new ParallelNetManager(ncell)}

{hostid = pnm.pc.id}

print "Set up ParallelNetManager managing ",ncell,"cells in total on: ", host, " with hostid: ", hostid


//  Initializes random-number generator

{use_mcell_ran4(1)}


//  As the simulation is being run in parallel, initialising differently on each host.
//  Adding the hostid to the rand seed allows reproducability of the sim, as long as the
//  same network distribution is used.

{mcell_ran4_init(520492214 + hostid)}

//////////////////////////////////////////////////////////////////////
//   Associating cells with nodes
//////////////////////////////////////////////////////////////////////


//  MPI Configuration: Local machine (2p) with 1 host, 2 processors

func getCellGlobalId() {

    if (strcmp($s1,"SampleCellGroup")==0) {

        //  There are 2 cells in this Cell Group
        cgid = 0 + $2
    }

    return cgid
}

{pnm.set_gid2node(getCellGlobalId("SampleCellGroup", 0), 0)}
{pnm.set_gid2node(getCellGlobalId("SampleCellGroup", 1), 1)}


//  Returns 0 or 1 depending on whether the gid for cell group $s1, id $2
//  is on this node i.e. via set_gid2node() or register_cell()
func isCellOnNode() {

    cellgid = getCellGlobalId($s1, $2)
    return pnm.gid_exists(cellgid)!=0
}



//////////////////////////////////////////////////////////////////////
//   Cell group 0: SampleCellGroup has cells of type: SampleCell
//////////////////////////////////////////////////////////////////////


//  Adding cell template file: SampleCell.hoc for cell group SampleCellGroup

{ load_file("SampleCell.hoc") }

//  Adding 2 cells of type SampleCell in region SampleRegion

{n_SampleCellGroup = 2}

{n_SampleCellGroup_local = 0 } // actual number created on this host

objectvar a_SampleCellGroup[n_SampleCellGroup]

for i = 0, n_SampleCellGroup-1 {
    if(isCellOnNode("SampleCellGroup", i)) {
        strdef reference, type, description
        sprint(reference, "SampleCellGroup_%d", i)
        sprint(type, "SampleCell")
        sprint(description, "A Simple cell for testing purposes")
        print "Going to create cell: ", reference, " on host ", host, ", id: ", hostid
        a_SampleCellGroup[i] = new SampleCell(reference, type, description)
        pnm.register_cell(getCellGlobalId("SampleCellGroup", i), a_SampleCellGroup[i])
        allCells.append(a_SampleCellGroup[i])
        n_SampleCellGroup_local = n_SampleCellGroup_local + 1 

    }
}


//  Placing these cells in a region described by: Rectangular Box from point: (0.0, 0.0, 0.0) to (100.0, 50.0, 100.0)


//  Packing has been generated by: Random: num: 2, edge: 1, overlap: 1, other overlap: 1

if (isCellOnNode("SampleCellGroup", 0)) {a_SampleCellGroup[0].position(45.934868,33.944996,88.97145)}
if (isCellOnNode("SampleCellGroup", 1)) {a_SampleCellGroup[1].position(60.27461,25.530382,67.46593)}


//////////////////////////////////////////////////////////////////////
//   Setting initial parameters
//////////////////////////////////////////////////////////////////////

strdef simConfig
{simConfig = "Default Simulation Configuration"}
{celsius = 6.3}



proc initialiseValues0() {


//  Setting initial vals in cell group: SampleCellGroup which has 2 cells


//  Giving all cells an initial potential of: -65.0

    for i = 0, n_SampleCellGroup-1 {
        if(isCellOnNode("SampleCellGroup", i)) forsec a_SampleCellGroup[i].all  v = -65.0

    }

}

objref fih0
{fih0 = new FInitializeHandler(0, "initialiseValues0()")}



//////////////////////////////////////////////////////////////////////
//   Adding Network Connections
//////////////////////////////////////////////////////////////////////

objectvar allCurrentNetConns
allCurrentNetConns = new List()

print " -----------------------   Starting generation of net conns on host: ", hostid


// Adding NetConn: NetConn_SampleCellGroup_SampleCellGroup from: SampleCellGroup to: SampleCellGroup with 1 connections
// each with syn(s): [ElectSyn [thresh: -20.0, delay: 5, weight: 1]]

//  Syn conn (type: ElectSyn) from Soma on src cell 0 to Soma on tgt cell 1
//  Fraction along src section: 0.5, weight: 1.0
//  Delay due to AP prop along segs: 0.0, delay due to AP jump pre -> post 3D location 0.0
//  Internal synapse delay (from Synaptic Props): 5.0, TOTAL delay: 5.0

objectvar elecsyn_NetConn_SampleCellGroup_SampleCellGroup_ElectSyn_A[1]

objectvar elecsyn_NetConn_SampleCellGroup_SampleCellGroup_ElectSyn_B[1]

if (isCellOnNode("SampleCellGroup", 1)) {
    a_SampleCellGroup[1].Soma { elecsyn_NetConn_SampleCellGroup_SampleCellGroup_ElectSyn_A[0] = new ElectSyn(0.5) }
    elecsyn_NetConn_SampleCellGroup_SampleCellGroup_ElectSyn_A[0].weight = 1.0
    pnm.pc.target_var(&elecsyn_NetConn_SampleCellGroup_SampleCellGroup_ElectSyn_A[0].vgap, 100000000)
    pnm.pc.source_var(&a_SampleCellGroup[1].Soma.v(0.5), 200000000)
}
if (isCellOnNode("SampleCellGroup", 0)) {
    a_SampleCellGroup[0].Soma { elecsyn_NetConn_SampleCellGroup_SampleCellGroup_ElectSyn_B[0] = new ElectSyn(0.5) }
    elecsyn_NetConn_SampleCellGroup_SampleCellGroup_ElectSyn_B[0].weight = 1.0
    pnm.pc.target_var(&elecsyn_NetConn_SampleCellGroup_SampleCellGroup_ElectSyn_B[0].vgap, 200000000)
    pnm.pc.source_var(&a_SampleCellGroup[0].Soma.v(0.5), 100000000)
}
print "++++++++++++"
print "Created netcons: ", allCurrentNetConns.count(), " on host ", hostid
for c = 0,allCurrentNetConns.count()-1 {
   print "Source of ", c,": ", allCurrentNetConns.o(c).precell(), ", gid: ",allCurrentNetConns.o(c).srcgid()   
}
print "++++++++++++"

pnm.pc.setup_transfer()

print " -----------------------   Finished generation of net conns on host: ", hostid
print "{}"
print ""

//////////////////////////////////////////////////////////////////////
//   Adding 1 stimulation(s)
//////////////////////////////////////////////////////////////////////

{ n_stim_SampleIClamp = 1 }
objectvar stim_SampleIClamp[n_stim_SampleIClamp]

if (isCellOnNode("SampleCellGroup", 0)) {

    //  Note: the stimulation was specified as being at a point 0.5 along segment: Soma

    //  in section: Soma. For NEURON, this translates to a point 0.5 along section: Soma

    a_SampleCellGroup[0].Soma {
        stim_SampleIClamp[0] = new CurrentClampExt(0.5)
        stim_SampleIClamp[0].del = 20.0
        stim_SampleIClamp[0].dur = 60.0
        stim_SampleIClamp[0].amp = 0.2
        stim_SampleIClamp[0].repeat = 0
    }
}



//  Cycling through cells and setting access to first one on this node

test_gid = 0
while (test_gid < ncell) {
    if (pnm.gid_exists(test_gid)) {
        objectvar accessCell
        test_gid = ncell
    } else {
        test_gid = test_gid + 1
    } 
}

//////////////////////////////////////////////////////////////////////
//   Settings for running the demo
//////////////////////////////////////////////////////////////////////


tstop = 100.0
dt = 0.02
steps_per_ms = 50.0
{pnm.set_maxstep(5)}


//////////////////////////////////////////////////////////////////////
//   This will run a full simulation of 5001 steps when the hoc file is executed
//////////////////////////////////////////////////////////////////////


//  Recording 1 variable(s)

objref v_time
objref f_time
objref propsFile

if (hostid == 0) {
    v_time = new Vector()
    { v_time.record(&t) }
    { v_time.resize(5001) } // false
    f_time = new File()
}


//  Saving VOLTAGE on only one seg, id: 0, in all 2 cells in SampleCellGroup


//  Creating vector for segment: Soma(ID: 0)

objref v_SampleCellGroup_seg_Soma_v[2]
for i=0, 1 {
    if (isCellOnNode("SampleCellGroup", i)) {
        { v_SampleCellGroup_seg_Soma_v[i] = new Vector() }
        { v_SampleCellGroup_seg_Soma_v[i].record(&a_SampleCellGroup[i].Soma.v(0.5))} 
        { v_SampleCellGroup_seg_Soma_v[i].resize(5001) }
    }
}
objref f_SampleCellGroup_seg_Soma_v[2]

strdef simReference
simReference = "Sim_7"





//  Note: to change location of the generated simulation files, just change value of targetDir
//  e.g. targetDir="" or targetDir="aSubDir/"

strdef targetDir
targetDir = "./"


//  Single simulation run...

strdef date
// Note: not showing date/time of start/stop of simulation. This requires Cygwin to be installed// which includes the "date" unix command. Install under c:\cygwin

setuptime = stopsw()

print "Setup time for simulation on host ",hostid,": ",setuptime," seconds"

{pnm.want_all_spikes()}
{stdinit()}
print "Initialised on ", host, ", hostid: ", hostid
{currenttime = startsw()}
print "Starting simulation of duration ",tstop,"ms, dt: ",dt,"ms, reference: ",simReference,""

{pnm.psolve(tstop)}
{realruntime = startsw() - currenttime}
print "Finished simulation in ", realruntime ,"seconds on host ", hostid

for i=0, pnm.spikevec.size-1 {
    print "Spike ",i, " at time ", pnm.spikevec.x[i]," in cell: ", pnm.idvec.x[i]
}
print "Storing the data..."

strdef timeFilename

//  Saving VOLTAGE on only one seg, id: 0, in all 2 cells in SampleCellGroup

if  (n_SampleCellGroup_local>0) { // No point in saving if no cells here...

 
//  Saving vector for segment: Soma(ID: 0)

for i=0, 1 {
    if (isCellOnNode("SampleCellGroup", i)) {
        f_SampleCellGroup_seg_Soma_v[i] = new File()
        strdef filename
        {sprint(filename, "%sSampleCellGroup_%d.dat", targetDir, i)}
        f_SampleCellGroup_seg_Soma_v[i].wopen(filename)
        v_SampleCellGroup_seg_Soma_v[i].printf(f_SampleCellGroup_seg_Soma_v[i])
        f_SampleCellGroup_seg_Soma_v[i].close()
    }
}

} // END:  if  (n_SampleCellGroup_local>0) 


if (hostid == 0) {
    { sprint(timeFilename, "%s%s", targetDir, "time.dat")}
    { f_time.wopen(timeFilename) }
    { v_time.printf(f_time) }
    { f_time.close() }
}

{savetime = stopsw()}

if (hostid == 0) {
    propsFile = new File()
    strdef propsFilename
    {sprint(propsFilename, "%ssimulator.props", targetDir)}
    {propsFile.wopen(propsFilename)}
    {propsFile.printf("#This is a list of properties generated by NEURON during the simulation run\n")}
    {propsFile.printf("Host=%s\n", host)}
    {propsFile.printf("RealSimulationTime=%g\n", realruntime)}
    {propsFile.printf("SimulationSaveTime=%g\n", savetime)}
    {propsFile.printf("SimulationSetupTime=%g\n", setuptime)}
    {propsFile.printf("NEURONversion=%s\n", nrnversion())}
    {propsFile.printf("NumberHosts=%g\n", pnm.pc.nhost)}
    {propsFile.close()}
}

    print "Data stored in ",savetime, "secs in directory: ", targetDir


//  Shutting down parallelisation




{pnm.pc.done}
